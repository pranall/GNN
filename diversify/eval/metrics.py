# -*- coding: utf-8 -*-
"""metrics

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fVas4vdh9iaV5Xmf7mbxsjnaB_eDUBKE
"""

import torch
import torch.nn.functional as F
import numpy as np
from sklearn.metrics import silhouette_score, davies_bouldin_score
from scipy.spatial.distance import cdist
import matplotlib.pyplot as plt

def compute_silhouette(features, labels):
    try:
        return silhouette_score(features, labels)
    except Exception as e:
        print(f"Silhouette error: {e}")
        return -1

def compute_davies_bouldin(features, labels):
    try:
        return davies_bouldin_score(features, labels)
    except Exception as e:
        print(f"Davies-Bouldin error: {e}")
        return -1

def compute_accuracy(model, loader):
    model.eval()
    correct, total = 0, 0
    with torch.no_grad():
        for data in loader:
            x = data[0].cuda().float()
            y = data[1].cuda().long()
            preds = model.predict(x)
            correct += (preds.argmax(1) == y).sum().item()
            total += y.size(0)
    return correct / total

def compute_h_divergence(source_feats, target_feats, discriminator):
    source_labels = torch.zeros(source_feats.size(0), dtype=torch.long).cuda()
    target_labels = torch.ones(target_feats.size(0), dtype=torch.long).cuda()
    feats = torch.cat([source_feats, target_feats], dim=0)
    labels = torch.cat([source_labels, target_labels], dim=0)
    preds = discriminator(feats)
    loss = F.cross_entropy(preds, labels)
    return loss.item()

def extract_features_labels(model, loader):
    features, labels = [], []
    model.eval()
    with torch.no_grad():
        for data in loader:
            x = data[0].cuda().float()
            y = data[1].cuda().long()
            feats = model.extract_features(x)
            features.append(feats.cpu().numpy())
            labels.append(y.cpu().numpy())
    return np.concatenate(features), np.concatenate(labels)


def plot_metrics(history_dict, save_dir="plots"):
    import os
    os.makedirs(save_dir, exist_ok=True)

    def plot_single(metric_name):
        plt.figure()
        for label, values in history_dict.items():
            if metric_name in values:
                plt.plot(values[metric_name], label=label)
        plt.title(f"{metric_name} over Epochs")
        plt.xlabel("Epoch")
        plt.ylabel(metric_name)
        plt.legend()
        plt.grid(True)
        plt.savefig(f"{save_dir}/{metric_name}.png")
        plt.close()

    for metric in ["train_acc", "valid_acc", "target_acc", "class_loss", "dis_loss"]:
        plot_single(metric)